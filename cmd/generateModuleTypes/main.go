package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
)

var (
	packageName string
	outputFile  string
	inputDir    string
	relativeTo  string
)

func init() {
	flag.StringVar(&packageName, "p", "", "Package name of generated source file")
	flag.StringVar(&outputFile, "o", "", "Filename for generated file")
	flag.StringVar(&inputDir, "i", "", "Input directory to process")
}

type module struct {
	jsonType string
	keys     []*moduleKeys
	name     string
}

type moduleKeys struct {
	name     string
	jsonType string
	suffix   string
}

func main() {
	flag.Parse()

	if packageName == "" {
		fmt.Println("Package name required")
		os.Exit(1)
	}
	if outputFile == "" {
		fmt.Println("Output file name required")
		os.Exit(1)
	}
	if inputDir == "" {
		fmt.Println("Input dir name required")
		os.Exit(1)
	}

	file, err := os.Create(outputFile)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	defer file.Close()

	if err := writeHeader(file); err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	modules, err := getModules(file)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	if err := writeModules(file, modules); err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	if err := writeControl(file, modules); err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
}

func writeHeader(w io.Writer) error {
	_, err := w.Write([]byte(fmt.Sprintf(`package %s

// DO NOT EDIT. This file is generated by ./cmd/generateModuleTypes/main.go.

import "fmt"

`, packageName)))
	return err
}

func getModules(w io.Writer) ([]*module, error) {
	files, err := ioutil.ReadDir(inputDir)
	if err != nil {
		return nil, err
	}

	var modules []*module

	for _, file := range files {
		filename := path.Join(inputDir, file.Name())
		f, err := os.Open(filename)
		if err != nil {
			return nil, err
		}
		reader := bufio.NewReader(f)
		_, _, err = reader.ReadLine()
		if err != nil {
			f.Close()
			return nil, err
		}

		genLine, _, err := reader.ReadLine()
		if err != nil {
			f.Close()
			return nil, err
		}
		f.Close()

		if !bytes.Equal(genLine[:11], []byte("#gen:module")) {
			log.Printf("Skipping file %s", file.Name())
			continue
		}

		genLineParts := bytes.SplitN(genLine, []byte(" "), 3)
		if len(genLineParts) != 3 {
			log.Printf("Invalid gen line in file %s", filename)
		}

		mod := &module{
			name:     file.Name()[:len(file.Name())-len(filepath.Ext(file.Name()))],
			jsonType: string(genLineParts[1]),
		}
		keys := bytes.Split(genLineParts[2], []byte(","))
		mod.keys = make([]*moduleKeys, 0, len(keys))

		for _, key := range keys {
			keyParts := strings.Split(string(key), ":")
			newKey := &moduleKeys{
				name:     keyParts[0],
				jsonType: keyParts[1],
			}

			if len(keyParts) == 3 {
				newKey.suffix = keyParts[2]
			}

			mod.keys = append(mod.keys, newKey)
		}

		modules = append(modules, mod)
	}
	return modules, nil
}

func writeModules(w io.Writer, modules []*module) error {
	for _, mod := range modules {
		fmt.Fprintf(w, "type %s struct {\n", goName(mod.name))
		for _, key := range mod.keys {
			fmt.Fprintf(w, "	%s %s `json:\"%s\"`\n", goName(key.name), key.jsonType, key.name)
		}
		fmt.Fprint(w, "}\n\n")

		if mod.jsonType == "a" {
			writeArrayPrint(w, mod)
		} else if mod.jsonType == "o" {
			writeObjPrint(w, mod)
		} else {
			return fmt.Errorf("Json type %s not supported", mod.jsonType)
		}
	}
	return nil
}

func writeArrayPrint(w io.Writer, mod *module) {
	srcName := goName(mod.name)
	fancyName := displayName(mod.name)

	fmt.Fprintf(w, `func printLong%s(a []*%s) {
	fmt.Println("%s:")
	for _, o := range a {
`, srcName, srcName, fancyName)

	for _, key := range mod.keys {
		fmt.Fprintf(w, "		fmt.Printf(\"%s: %s%s\\n\", o.%s)\n",
			displayName(key.name),
			fmtType(key.jsonType),
			key.suffix,
			goName(key.name),
		)
	}

	fmt.Fprint(w, "		fmt.Println(\"\")\n	}\n}\n\n")
}

func writeObjPrint(w io.Writer, mod *module) {
	srcName := goName(mod.name)
	fancyName := displayName(mod.name)

	fmt.Fprintf(w, `func printLong%s(a *%s) {
	fmt.Println("%s:")
`, srcName, srcName, fancyName)

	for _, key := range mod.keys {
		fmt.Fprintf(w, "	fmt.Printf(\"%s: %s%s\\n\", a.%s)\n",
			displayName(key.name),
			fmtType(key.jsonType),
			key.suffix,
			goName(key.name),
		)
	}

	fmt.Fprint(w, "}\n\n")
}

func writeControl(w io.Writer, modules []*module) error {
	fmt.Fprint(w, "type HostResponse struct {\n	Host *ConfigHost `json:\"host\"`\n")
	for _, mod := range modules {
		srcName := goName(mod.name)
		fmt.Fprintf(w, "	%s %s*%s `json:\"%s,omitempty\"`\n",
			srcName, srcType(mod.jsonType), srcName, mod.name,
		)
	}
	fmt.Fprint(w, `}

func (r *HostResponse) Print(short bool) {
	if r == nil {
		return
	}

	if short {
		r.printShort()
		return
	}
	r.printLong()
}

func (r *HostResponse) printShort() {
	// TODO
}

`)

	fmt.Fprint(w, "func (r *HostResponse) printLong() {\n")

	for _, mod := range modules {
		srcName := goName(mod.name)
		if mod.jsonType == "a" {
			fmt.Fprintf(w, `	if len(r.%s) > 0 {
		printLong%s(r.%s)
		fmt.Println("")
	}
`, srcName, srcName, srcName)
		} else if mod.jsonType == "o" {
			fmt.Fprintf(w, `	if r.%s != nil {
		printLong%s(r.%s)
		fmt.Println("")
	}
`, srcName, srcName, srcName)
		}
	}

	fmt.Fprint(w, "}\n\n")
	return nil
}

func srcType(t string) string {
	switch t {
	case "a":
		return "[]"
	}
	return ""
}

func fmtType(t string) string {
	switch t {
	case "string":
		return "%s"
	case "float64":
		return "%.2f"
	case "bool":
		return "%t"
	case "int":
		return "%d"
	}
	return ""
}

func displayName(s string) string {
	s = strings.Replace(s, "_", " ", -1)
	s = strings.Title(s)
	return s
}

func goName(s string) string {
	s = displayName(s)
	s = strings.Replace(s, " ", "", -1)
	s = strings.Replace(s, "(", "", -1)
	s = strings.Replace(s, ")", "", -1)
	s = strings.Replace(s, "-", "", -1)
	return s
}
